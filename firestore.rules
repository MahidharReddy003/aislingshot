rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE PHILOSOPHY:
     * This ruleset enforces a strict User-Ownership model. Every piece of data in the system is 
     * logically and physically partitioned under a specific user's root document. This creates 
     * a secure sandbox where users can only access and modify their own AI recommendations, 
     * settings, and activity history.
     *
     * DATA STRUCTURE:
     * All application data is nested under the hierarchical path `/users/{userId}/...`. 
     * Subcollections like 'preferences', 'budgetRules', and 'recommendations' are 
     * isolated per user.
     *
     * KEY SECURITY DECISIONS:
     * 1. Authorization Independence: Every document contains a denormalized 'userId' field 
     *    that must match the path's {userId} wildcard and the requester's 'request.auth.uid'. 
     *    This avoids expensive get() calls and ensures rules are performant.
     * 2. Self-Creation: Users are allowed to create their own profile document if the 
     *    document ID matches their Authentication UID.
     * 3. Resource Protection: Update and Delete operations strictly require the 
     *    resource to exist and the requester to be the verified owner.
     * 4. Flexible Schema: While ownership and relational IDs are strictly enforced 
     *    to maintain integrity, general data shapes are left flexible for rapid prototyping.
     */

    // --- GLOBAL HELPER FUNCTIONS ---

    /**
     * @description Checks if the user is authenticated with Firebase Auth.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Combines ownership check with existence check for destructive operations.
     */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    /**
     * @description Validates that the userId in the data matches the path and is immutable.
     */
    function hasValidUserLink(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * @description Ensures the userId link cannot be changed during an update.
     */
    function isUserLinkImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // --- COLLECTION RULES ---

    /**
     * @description Rules for the root UserProfile entity.
     * @path /users/{userId}
     * @allow (create) if auth.uid matches {userId} and internal data IDs match.
     * @deny (get) if auth.uid does not match {userId}.
     * @principle Enforces self-creation and strict ownership of the user profile.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId && request.resource.data.firebaseAuthUid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id && request.resource.data.firebaseAuthUid == resource.data.firebaseAuthUid;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Rules for User Preferences (Settings).
       * @path /users/{userId}/preferences/{prefId}
       * @allow (update) if is the owner of the parent user document.
       * @deny (create) if the userId in the data doesn't match the path.
       * @principle Path-based ownership with data-link validation.
       */
      match /preferences/{prefId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for User Budget Rules.
       * @path /users/{userId}/budgetRules/{ruleId}
       * @allow (list) if is the authenticated owner.
       * @deny (update) if trying to change the owner of the rule.
       * @principle Ensures budget constraints are private and immutable regarding ownership.
       */
      match /budgetRules/{ruleId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for AI-generated Recommendations.
       * @path /users/{userId}/recommendations/{recId}
       * @allow (get) if the recommendation belongs to the user.
       * @deny (write) if the auth.uid does not match the parent userId.
       * @principle Protects the privacy of AI insights and history.
       */
      match /recommendations/{recId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for User Feedback on recommendations.
       * @path /users/{userId}/feedback/{feedbackId}
       * @allow (create) if the user is submitting feedback for their own account.
       * @deny (list) if accessed by a different user.
       * @principle Relational integrity: links feedback to both the user and the recommendation.
       */
      match /feedback/{feedbackId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for Saved Items and Favorites.
       * @path /users/{userId}/savedItems/{itemId}
       * @allow (create) if the user saves an item to their own list.
       * @deny (delete) if the user does not own the specific item.
       * @principle Restricts personal 'Saved' collections to the owner.
       */
      match /savedItems/{itemId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for custom User Collections.
       * @path /users/{userId}/collections/{colId}
       * @allow (list) if the user is viewing their own folders.
       * @deny (update) if changing the userId field.
       * @principle Supports organizational features with strict access control.
       */
      match /collections/{colId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for Activity Logs and Audit Trails.
       * @path /users/{userId}/activityLogs/{logId}
       * @allow (create) if the system/user records an event.
       * @deny (update) as activity logs should generally be append-only.
       * @principle Ensures a private, immutable audit trail of user interactions.
       */
      match /activityLogs/{logId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserLink(userId);
        allow update: if isExistingOwner(userId) && isUserLinkImmutable();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}