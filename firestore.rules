rules_version = '2';

/**
 * Explainable AI Consumer Experience Platform - Firestore Security Rules
 * 
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model designed for an Explainable AI platform. 
 * The primary goal is to ensure that personalized recommendations, feedback, and settings 
 * remain private to the individual user while allowing public access to the shared 
 * library of categories and recommendation items.
 *
 * Data Structure:
 * The data is organized into two main categories:
 * 1. User-Scoped Data: Nestled under `/users/{userId}/...`. This includes profiles, 
 *    preferences, AI recommendations, feedback, and collections.
 * 2. Global Public Data: Top-level collections for `/categories` and `/recommendation_items` 
 *    which serve as the "catalog" for the AI system.
 *
 * Key Security Decisions:
 * - Ownership Enforcement: All user data requires the authenticated UID to match the 
 *   {userId} path segment.
 * - Relational Integrity: Documents within user paths must contain a 'userId' field 
 *   matching the path to ensure data consistency and allow for future query-based rules.
 * - Public Read-Only: Categories and Recommendation Items are publicly viewable by 
 *   anyone (including unauthenticated users) to facilitate the "Try Demo" experience, 
 *   but writes are strictly prohibited via rules (intended for admin/system use only).
 * - Prototyping Flexibility: Rules do not enforce strict data types or schemas, 
 *   allowing for rapid iteration of the AI data models.
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    /** @description Checks if the request is from a signed-in user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** @description Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** @description Checks ownership and ensures the document exists for update/delete operations. */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // --- Collection Rules ---

    /**
     * @description User Profile management. Users can only manage their own profile.
     * @path /users/{userId}
     * @allow (get) If the user is the owner. (create) If the UID matches and internal ID is set correctly.
     * @deny (list) Generally restricted or limited to owner only.
     * @principle Self-creation and ID-to-Path consistency.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description User Preferences and Settings. Influences AI transparency and budget controls.
     * @path /users/{userId}/preferences/{preferenceId}
     * @allow (create) If userId field matches the authenticated user.
     * @deny (update) If the userId field is being changed.
     * @principle Path-based ownership with relational integrity checks.
     */
    match /users/{userId}/preferences/{preferenceId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description AI-generated Recommendations. Private to the user.
     * @path /users/{userId}/recommendations/{recommendationId}
     * @allow (list) The owner can view their recommendation history.
     * @principle User-scoped subcollections for privacy.
     */
    match /users/{userId}/recommendations/{recommendationId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description User Feedback on AI explanations. Used for the improvement loop.
     * @path /users/{userId}/feedback/{feedbackId}
     * @allow (create) Authenticated user submitting their own feedback.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/feedback/{feedbackId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Saved items and Favorites.
     * @path /users/{userId}/saved_recommendations/{savedRecommendationId}
     * @allow (get) If user owns the saved entry.
     * @principle Authorization Independence via Denormalization (userId field check).
     */
    match /users/{userId}/saved_recommendations/{savedRecommendationId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Custom collections for organizing saved recommendations.
     * @path /users/{userId}/collections/{collectionId}
     * @allow (update) The owner can rename or describe their collections.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/collections/{collectionId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Public categories for recommendation filtering.
     * @path /categories/{categoryId}
     * @allow (get, list) Open to all users to see valid options.
     * @deny (write) Users cannot modify system-defined categories.
     * @principle Public read with strictly controlled writes.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Category' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner/admin validation once schema supports it.
    }

    /**
     * @description Public library of items that can be recommended.
     * @path /recommendation_items/{itemId}
     * @allow (get, list) Open for browsing/searching.
     * @deny (write) Items are managed by the platform, not individual consumers.
     * @principle Structural segregation of public and private data.
     */
    match /recommendation_items/{itemId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'RecommendationItem' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner/admin validation once schema supports it.
    }
  }
}